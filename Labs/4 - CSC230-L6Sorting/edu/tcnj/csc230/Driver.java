/** * @author Kevin Bohinski <bohinsk1@tcnj.edu> * @author Maulik Patel <patelm21@tcnj.edu> * @version 1.0 * @since 2014-04-24 *  * Spring 2014  * CSC 230 Lab 6 Sorting *  * Driver.java *//** Setting Package **/package edu.tcnj.csc230;/** Setting Imports **/import java.util.*;import java.io.*;import java.lang.*;import java.lang.System.*;import java.math.BigInteger;import java.text.*;import java.net.*;import jsjf.Sorting;public class Driver {	/** Setting Vars **/	static Person[] people = new Person[70000];	/**	 * main method, executes the sorting analysis program	 * 	 * @param args	 */	public static void main(String[] args) throws IOException,			MalformedURLException {		System.out.println("Downloading Data");		Scanner urlIn = new Scanner(				new URL(						"http://s3.amazonaws.com/depasquale/datasets/namesWithBloodType.txt")						.openStream());		System.out.println("Done\n");		System.out.println("Parsing Data");		while (urlIn.hasNext()) {			for (int i = -1; urlIn.hasNext(); i++) {				String line = urlIn.nextLine();				String[] parts = line.split("\\|");				if (i == -1) {					// Skips Header Line				} else {					String givenName = parts[0];					String surName = parts[1];					String address = parts[2];					String city = parts[3];					String state = parts[4];					int zipCode = Integer.parseInt(parts[5]);					String bloodType = parts[6];					Person tmp = new Person(givenName, surName, address, city,							state, bloodType, zipCode);					people[i] = tmp;				}			}			/** End for(int i = -1; urlIn.hasNext(); i++) **/		}		/** End while(urlIn.hasNext()) **/		urlIn.close();		System.out.println("Done\n");		System.out.println("Sorting Comparison");		Scanner input = new Scanner(System.in);		System.out				.println("Enter your desired number of elements to sort (from 1-70000): ");		int numToRun = input.nextInt();		Person[] toSortBubble = new Person[numToRun];		Person[] toSortInsertion = new Person[numToRun];		Person[] toSortSelection = new Person[numToRun];		Person[] toSortMerge = new Person[numToRun];		Person[] toSortQuick = new Person[numToRun];		System.out.println("Preparing data to sort");		for (int i = 0; i < numToRun; i++) {			toSortBubble[i] = people[i];			toSortInsertion[i] = people[i];			toSortSelection[i] = people[i];			toSortMerge[i] = people[i];			toSortQuick[i] = people[i];		}		/* Setting arrays to null due to memory issues on linux lab computers */		people = null;		System.out.println("Done\n");		System.out.println("Starting Comparisons:");		long st = System.nanoTime();		Sorting.bubbleSort(toSortBubble);		long et = System.nanoTime();		long tBubble = et - st;		long cBubble = 0;		for(int i = 0; i < numToRun; i++){			cBubble = cBubble + toSortBubble[i].getCount();		}		toSortBubble = null;		st = System.nanoTime();		Sorting.insertionSort(toSortInsertion);		et = System.nanoTime();		long tInsertion = et - st;		long cInsertion = 0;		for(int i = 0; i < numToRun; i++){			cInsertion = cInsertion + toSortInsertion[i].getCount();		}		toSortInsertion = null;		st = System.nanoTime();		Sorting.selectionSort(toSortSelection);		et = System.nanoTime();		long tSelection = et - st;		long cSelection = 0;		for(int i = 0; i < numToRun; i++){			cSelection = cSelection + toSortSelection[i].getCount();		}		toSortSelection = null;		st = System.nanoTime();		Sorting.mergeSort(toSortMerge);		et = System.nanoTime();		long tMerge = et - st;		long cMerge = 0;		for(int i = 0; i < numToRun; i++){			cMerge = cMerge + toSortMerge[i].getCount();		}		toSortMerge = null;		st = System.nanoTime();		try {			Sorting.quickSort(toSortQuick);		} catch (StackOverflowError e) {			System.out.println("Quick Sort failed, too many recursive calls.");		}		et = System.nanoTime();		long tQuick = et - st;		long cQuick = 0;		for(int i = 0; i < numToRun; i++){			cQuick = cQuick + toSortQuick[i].getCount();		}		toSortQuick = null;		System.out.println("Done\n");		System.out.println("Outputting to output.txt");		try{			BufferedWriter out = new BufferedWriter(new FileWriter("output.txt"));			out.write("Sorting results for (" + spaceFormat(customFormat("##,###", numToRun), 6) + " Person objects)");			out.newLine();			out.newLine();			out.write("Sort Name\t\t# Comparisons\t\t# Nanoseconds");			out.newLine();			out.write("------------------------------------------------------------------------------");			out.newLine();			/*Sort in nanoseconds, highest to lowest*/			Long[] times = new Long[5];			times[0] = tBubble;			times[1] = tSelection;			times[2] = tInsertion;			times[3] = tMerge;			times[4] = tQuick;			Sorting.mergeSort(times);			for(int i = 4; i >= 0; i--){				if(times[i] == tBubble){					out.write("bubble\t\t\t"+ spaceFormat(customFormat("###,###,###,###", cBubble), 15) + "\t\t" + spaceFormat(customFormat("###,###,###,###", tBubble), 15));					out.newLine();				}else if(times[i] == tSelection){					out.write("selection\t\t"+ spaceFormat(customFormat("###,###,###,###", cSelection), 15) + "\t\t" + spaceFormat(customFormat("###,###,###,###", tSelection), 15));					out.newLine();				}else if(times[i] == tInsertion){					out.write("insertion\t\t"+ spaceFormat(customFormat("###,###,###,###", cInsertion), 15) + "\t\t" + spaceFormat(customFormat("###,###,###,###", tInsertion), 15));					out.newLine();				}else if(times[i] == tMerge){					out.write("merge\t\t\t"+ spaceFormat(customFormat("###,###,###,###", cMerge), 15) + "\t\t" + spaceFormat(customFormat("###,###,###,###", tMerge), 15));					out.newLine();				}else if(times[i] == tQuick){					out.write("quick\t\t\t"+ spaceFormat(customFormat("###,###,###,###", cQuick), 15) + "\t\t" + spaceFormat(customFormat("###,###,###,###", tQuick), 15));					out.newLine();				}			}			out.close();		}catch(IOException e){			System.out.println("Error writing out to file");		}		System.out.println("Done");	}	/** End main method **/	/**	 * Returns a prettified version of the input.	 * 	 * @param pattern	 *            Desired pattern	 * @param value	 *            Input value	 */	private static String customFormat(String pattern, double value) {		DecimalFormat myFormatter = new DecimalFormat(pattern);		String output = myFormatter.format(value);		return output;	}	private static String spaceFormat(String input, int width) {		return String.format("%1$"+width+ "s", input);	}}/** End public class Driver **/